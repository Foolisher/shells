# 走近敏捷

> 从没有最厉害的招式和套路，因为一成不变的招式再厉害也有它的克星，厉害的武学应该是来源于内功的修炼，有敏捷应万变之功，所谓无招胜有招

敏捷是一个持续过程，是一种习惯和思想，是把设计原则发挥的恰到好处的艺术

提到软件设计，许多人会想到一系列设计模式，或架构框图，或经典软件工程学，或UML，哪些模式用于哪些场景，可以解决那些常规的设计场景，使我们的程序结构更加优雅，增强可读性与可维护性。但软件设计也不全是设计模式，过于套路会陷于花拳绣腿；但不懂套路也会显得杂乱笨拙

一个全新的系统就像一辆刚设计好的车，轻而快，业务的加入一方面给他换了引擎，换上了防撞梁，加上了门窗，汽车跑的更快了，同时汽车也更加重了。但改装的过程，若不注重设计上各个零部件的良好协作，不但会让汽车变得越来越丑陋，同时汽车的结构会变得脆弱，更难改进，维修成本也加大，性能被拖垮。

在敏捷的世界里，没有套路的方法论，不一定是文档先行，不一定讲究多NB的架构，也不一定有洋洋洒洒的详细技术文档，`package`/`package-info.java` 就是模块设计 / 代码结构就是详细设计 / 达意的类名,方法名,逻辑块就是注释。

## 为什么需要敏捷

有没有如下的经历？

* 没有没被业务方追着赶一个特殊需求而找到判断的地方加入过一个 `if/else` 判断搞定的经历，找到后发现好多人都在这里加了这样的 `if/else`...

* 改一段别人的代码总是如履薄冰，因为曾经好多次改别人的代码实现了功能却引起了其他故障

* 一个明明有特殊含义的类，却有几百行代码，好像里面什么逻辑都有，一头扎进去就理不清了

## 敏捷开发信条

> * 不要一来就谈哪个框架是个好东西，罗列出它的诸多优点，这就是成了选它的原因，合适的才是最好的。选型当分场景而定，好东西尽管是好东西，但需避免引入不必要的依赖和复杂度，简单地解决问题是第一原则。尽管设计一直提倡抽象能力，但也不是一上来就抽象，因为许多地方根本用不着抽象，本是一个简单的过程就覆盖了需求，若强行引入抽象那样的代码就看起来真的“抽象”了
>
> * 没有万金油的套路，应谨记设计原则才是修炼内功，因为所有的套路都是衍生于经典原则，优秀的开发是不知不觉按自己的经验重构成了经典设计模式的样子，而不是先从套模式开始...
>
> * 一直不变的就是一直在变的需求，敢于拥抱变化，激励变化，才是对系统良好设计的考验，既然无法改变需求善变的现状，就接受它吧

### ◎ 一些设计原则

1. **稳定性**

   接口稳定性，结构稳定性，在需求变更重构时功能模块的稳定性体现了设计的粒度张弛度，对接口设计的严谨要求较高。稳定性对设计的前瞻性有一定要求，要求设计接口的通用性。一个地方的修改不会引起更多地方的错误，对功能的扩展是通过添加代码而不是修改代码实现的

   _解决之道:_ 抽象接口 / 单一职责 / 域控制\(隔离\)

2. **简洁是王道**

   不过度设计，但又要保证设计满足需求的同时是保证易扩展性。但在把握简介与扩展性的边界上就看实现者的水平了。

   _解决之道:_ 轻结构 / 先满足关键需求 / 无招式的模式，不套模式，重构出模式

3. **消除重复代码**

   发现相似逻辑出现了2次就应该要求自己抽取成公用服务。尽量不要copy代码，copy代码容易带来重复代码。消除重复代码包括消除魔法数字，通用工具，横切逻辑等

   _解决之道:_ 抽取方法 / 定义常量 / 抽象模板

4. **不依赖环境**

   不同环境有一套完整的机制，协作开发对环境应该是透明的，环境应与系统解耦

   _解决之道:_ 隔离多套 / 参数化动态植入

5. **透明的**

   对上层屏蔽下层细节，为上层提供简介api。

   _解决之道:_ 分层 / 面向抽象接口 / 收拢入口

### ◎ 单一职责原则SRP: Single-Responsibility Principle

> 当要修改这个服务时必须因为一个具体的服务逻辑：以此约束这个逻辑里只有单纯的某个业务逻辑；
>
> 但若很小的粒度方法一来就要拆分隔离，势必造成类膨胀，这也是不好的，或许也是没有必要的，恰当的做法是适当地将具有相关相似域的放在一起，我们也要遵循一定的领域模型，换句话说，我们期望支持领域级别的单一职责原则，后续详细讨论领域相关原则

#### 优点

1. 隔离服务，减小粒度，降低影响

2. 拆解服务，增强复用度，也让接口更简洁，易用

### ◎ 开闭原则OCP: Open/Close Principle

#### 优点

1. 关闭修改，避免因修改引入错误

2. 通过增加实现高层抽象增强功能，不用像通过修改那样去寻找修改点，修改起来更容易

#### 关键点

* 通过抽象对付变化

* 多考虑前瞻性：若这里变化了，会如何变化？会变化成什么样？当有改动时如何让这里的改动代价是最小的？这里的逻辑是否足够覆盖需求？抑或是否存在过度设计？

> **但是**关闭其实也不是绝对的，例如重构时就需要对已有的代码进行修改调整，使其拓展性更强；或者说必须经过修改来让模块的结构更加强大，这都会依赖于设计者对行业背景的了解程度和一些经验积累，以判断该“关闭”哪些或“关闭”到什么样的程度才利于模块的扩展

### ◎ 里氏替换原则LSR:  Liskov Substitution Principle

具体逻辑是抽象化了的，同时对使用者又是透明的，LSR是在遵循依赖抽象的原则下对抽象合理性的检测。如果抽象了，还发现控制逻辑里面有大把的`instanceof`断言来路由不同的实例，那么说明抽象程度是不够或不对的，若抽象了还要对不同实例不同处理还干嘛抽象呢？因此在抽象的入口逻辑，应当对实现一视同仁，否则就是违背了LSR。

当然实际情况中确实常常有对不同的实例有不同的判断路由，但至少这个判断路由我们应该交给具体实现了决策，或解耦出一层特定的路由决策规则，而不是在上层控制逻辑中侵入下层的代码，一句话以概之：**共性逻辑往上浮，个性逻辑往下沉，**该原则通用于任何场景**。**保持金字塔形式的单向一致向上依赖，绝不出现循环依赖

#### 优点

### ◎ 依赖倒置原则DIP: Dependency-Inversion Principle

高层api不能依赖底层实现，底层实现依赖高层api的抽象。依赖抽象，屏蔽细节，保障高层api不被底层的改动而影响，不被具体的实现侵入，使模块可复用，结构更稳定，拓展更灵活...举个形象的例子，一个机械要用到一个工具，若工人把这个工具焊在上面，看起来这个功能可以用了，但是有天发现要更替一个功能时，又得要焊工把先前那个敲掉，然后再焊接一个，有人发现这个过程相当繁琐，干脆定义一个螺帽在上面，要加什么工具或换什么工具时相应工具上有个对应螺栓拧上去拧下来就做到了，变更过程更容器也避免了重新焊接敲坏主板的可能，而这里的螺母/螺栓就是接口，不同的工具就是具体实现。

### ◎ 接口分离原则ISP: Interface Segregation Principle



