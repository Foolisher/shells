## 一、免密支付需求

### 1.1. 亲淘免密支付背景

为给用户提供快捷的在线支付下单体验，有的应用与三方支付平台打通了免密支付渠道，在用户认可的情况下，下单支付时用户无须进入收银台输入密码确认支付即可让三方支付平台代为扣费完成一次交易，带来非常方便的交易体验。如常用的滴滴打车免密支付，叫到车到乘车结束然后下车即可，无需乘客特意去付款，直接走人，滴滴后台结算本次订单金额然后直接让支付平台扣款。

当然这样的免密支付是在用户+应用+支付平台三者信用为背书前提下建立的信用支付方式。用户签约开通免密支付，下次支付时直接提交订单让APP帮代扣，自己无须再与支付平台打交道了，以支付宝开通免密支付为例，下图是支付宝提供的免密支付开通流程：

![](https://gw.alipayobjects.com/zos/skylark/18f57ae3-76c7-4bb0-b93d-5f0b856ebae6/2018/png/9fbb605d-bb7f-48cd-b4a3-e55359f32cba.png)



开通后免密支付的效果如下图，提交订单到支付一步到位：

![](https://gw.alipayobjects.com/zos/skylark/a46c1852-9a65-402c-978e-d8111aa1dcc8/2018/png/b4879627-88ff-4b0a-b806-abb918d16920.png)

### 1.2. 要做什么

从Buy2系统角度来说，一个商户应用要开通免密支付要做如下步骤：

* 渲染免密支付Switch开关，让用户决定是否签约并使用免密支付

* 免密支付使用前提限制：规避不适合免密支付的商品如虚拟商品；用户选择的三方支付平台是否支持免密支付代扣如支付宝是否支持这样的功能；订单金额限制在多少内可以使用免密支付；满足以上条件时方可使用免密支付

* 与支付宝打通免密支付签约接口

* 用户不想使用免密支付了，要有入口让用户自己解约免密支付，转为普通支付

* 与支付宝打通免密支付接口，与普通唤起收银台用户输入密码的支付方式有别

### 1.3. 怎么做

弄清需求后就开始规划在交易系统里面如何支持免密支付功能，如此，按业务流程来梳理该功能是如何实现的

1. 怎么渲染免密支付Switch控件，交易系统目前前端控件是如何渲染的？

2. 免密支付控件的渲染是需要有逻辑控制的，如已签约了是不能展示这个控件的，那么控制hidden逻辑在哪？

3. 然后控件的勾选状态是如何获取的，即交易后端如何知道用户是否勾选了免密支付，在结算时才可决策是否走支付宝的免密支付接口而不是普通的密码支付？

4. 构建免密支付API在交易的哪个扩展点？

以下，通过对交易系统的梳理，对上述问题进行分析：

> 1. 目前交易的前端渲染逻辑是由[奥创](https://www.atatech.org/articles/64140)来做的，在[奥创系统](http://ultronage.alibaba-inc.com/structure/structureList.htm?domainId=2)的交易模块域\(buy2\)页面配置一个免密支付的Switch控件，即可在前端透出，后面会详述奥创控件配置
>
> 2. 首先，控制逻辑是在交易后端判断的，然后奥创在序列化业务数据时按这个渲染控制逻辑映射到组件的渲染控制逻辑上，前端按标准的组件渲染属性判断处理，如后端`nopwdpay.hidden`属性或许对应前端的`switch.visible=false`，有点抽象，这个逻辑下面叙述
>
> 3. 这个也要和奥创打交道了，前端提交上来的参数，要经过奥创进行一次参数反序列化映射到我们后端系统的业务模型中，配置过Mtop会有点概念，如前端可以传来的参数是`a=xxx&b=2&c=1.1.0.1`，可以映射成某HSF接口对应顺序的`a=>name,b=>addr,c=>ip`三个参数上
>
> 4. 如果后端收到用户已勾选同意使用免密支付开关，那么后端需要在支付域的构建支付宝请求参数的扩展点上植入这个逻辑。目前交易大部分系统都是基于[TMF2](http://tmf.alibaba.net/)构建的，有兴趣可以了解下TMF的设计思想，开发模型了解，参照tmf-sample工程对基于TMF构建自己的应用quick start

上述只是对该需求的业务背景，技术方案有一个大概的认识，下面会对实际开发流程做实际描述

## 二、怎么渲染免密支付Switch滑块



### 2.1. 什么是奥创

我们都已经获知交易的许多页面都是通过奥创平台来配置并渲染的，那么首先需要知道奥创做了些啥，是怎么做的。

首先，我们都熟知的人机交互是通过用户与客户端的控件加事件来与后端服务器进行互动的，例如`Input`输入框，`Button`按钮，但是每一个客户端对这些控件都有自己的渲染语法，如IOS，Android，H5，它们的渲染语法又都是不一样的，鉴于目前大多数应用都会提供多端，才能让用户在不同场景都能使用我们的服务。那么这么多客户端，如果某天需求变更要新增一个`Input`控件，就得找到三个端的开发协同为我们开发这个控件，然后约定传输字段field，验证逻辑，然后发布APP…。这套流程下来就要投入端的倍数的人力，后端也同样，对不同端有不同的处理，参数接收，返回数据约定。

其实想想这个逻辑其实是雷同的，只是由于不同的端，copy了一份相同的逻辑了，那么这个重复劳动能不能交给一个中间件做呢，它来约定一个基础控件如Input要传哪些参数诸如`{name,visible,editable,validation}`等，由中间件实现这个组件元数据在不同端的渲染逻辑，那么以后任何的Input控件渲染，只需给出这个控件定义即可，后端无需关心前端怎么做，这个中间件（SDK）只需按控件定义渲染即可，是不是有点像JVM，一套代码，处处运行。

这就是MVVM\(Model–view–viewmodel\)思想解决思路：**通过组件元数据约束了前后端组件渲染/交互规范**，加上SDK，实现一套代码（配置），多端通用。约束了组件接口协议、通过SDK渲染控件、通过组件复用提高开发效率。在此基础上，并为页面设计了组件布局，让组件组合起来成为一个完整的页面，这就是奥创。



### 2.2. 奥创是怎么渲染控件的

![](https://gw.alipayobjects.com/zos/skylark/5a87479c-f268-4532-943d-c91de66868ac/2018/png/6f642547-f6ad-4e35-a4b8-94edf16e5697.png)

以下单页为例，捕获到下单页构建订单信息的json信息如上图左数据结构所示。

`data`定义了所有组件的元数据及业务数据，例如地址控件的收货人、手机号、地址等信息，客户端再根据自己平台语法渲染这个控件；

`hierarchy.structure`定义了页面结构布局，里面包括有哪些控件，控件的顺序，如`hierarchy.root`指定这个页面的root是`confirmOrder_1`，`confirmOrder_1`只是个组件id，它可以在data中找到；然后`confirmOrder_1`里面有`order_acfd3b78f11835ad3c915e9e8ab3cc17`订单**区块**，这个区块里面有商品信息、购买数量、店铺优惠… 等组件，这些结构都是在奥创的区块管理里面定义的

![](https://gw.alipayobjects.com/zos/skylark/c3248072-86ed-4627-9761-e6bb3a292a50/2018/png/bfd41373-7247-44e3-b405-2856c4d39b0f.png)

回顾图一可以看出页面数据的布局就是在json的`hierarchy.structure`里面定义的，而这个结构数据又是在上图的结构化管理里面定义的，现在页面布局知道了，控件元数据与控件是怎么对应起来的也知道了，那么控件的元数据又是怎么`set`到`data`里面的，比如`withholding`\(免密支付`Switch`\)控件里面`fields`参数是怎么放进去的呢？下面以配置免密支付Switch开关为例，看看数据产生链路是怎么产生的：

![](https://gw.alipayobjects.com/zos/skylark/c30f5819-6fbd-4a66-8f3b-e6bbab3a94dd/2018/png/1453e9de-1125-42a2-aaa6-ad58eec06efc.png)



### 2.3. 奥创还能做什么

在摸索奥创开发的过程中，没有QuickStart，如果根据已有项目直接操作，会较难找到开边，尽管感觉MVVM是那么回事，但是咋搞起来的呢，流程是怎样的呢，翻阅了许多文档才知道个大概。奥创操作界面上较难看出来这个操作是干啥的，比如我要开发一个Switch开关，这应该是一个通用控件，但是我怎么把我的组件withholding\[免密支付\]渲染成一个Switch呢，后来经过观察发现组件数据有个`type=toggle`它就可以被前端渲染成一个普通的Switch控件，而这个设置就在组件编辑的底栏【选择组件】处，要不是试了下咋知道是这样搞的呢。

虽然后面看到许多问题其实在开发[Issues](http://gitlab.alibaba-inc.com/ultron/ultron-doc/issues)里面能找到，但是对系统不熟悉的人，看这样的标题没有目标性和系统性，要是形成一个Gitbook格式的教程就好了或者在系统操作界面加上链接也好。将开发手册的Issues按步骤文档化，要不然有点跳跃。

奥创已约束了`ViewModel`的交互协议，但是对于前端，大部分都是业务组件居多，组件的复用程度会受基础组件的组合能力而影响



## 三、怎么知道用户有没有打开免密支付开关

既然用到奥创规范的`ViewModel`渲染组件，前端也是用这个`ViewModel`提交请求数据的，那么请求参数自然是从这个`ViewModel`中来，我们只要知道怎么将这个`ViewModel`中的对应的参数映射到业务`Bean`的字段上，就能拿到用户提交上来的数据了

### 3.1. 奥创是怎么组件回收的

奥创里面有个**组件回收**的概念，就是怎么将前端提交的json映射到我们业务流程入口处用来接收这坨json数据值的Bean上，以便在业务流程中能get到。例如买家留言组件是一个`Input`控件，提交时这个控件的值会提交上来，那么怎么让奥创知道这个控件提交的值`set`到哪个`Bean`的字段上呢？

![](https://gw.alipayobjects.com/zos/skylark/4837587f-48eb-45ae-b444-2c423346b64a/2018/png/7b0142fb-275f-42ed-9ae8-5e2e6f455c54.png)

上面例子的`withholding`组件由于没有在业务模型Model中定义，需要利用`CustomizedView`加进去

当然如果我们的业务`Model`上有回收组件值的`field`，则直接引用`set`方法，奥创会用反射方式将其`set()`进去，如下单模型里面的`memo`（卖家留言信息），它再`OrderDTO`里面

```
OrderCreatingRequest
: 
# 订单创建Bean，用来接收整个ViewModel映射来的值


  OrderDTO
: 
# 订单Bean 


  memo
: 
# 买家留言(String)
```

对于上面已存在的field定义，奥创上配置`orderCreatingRequest.getOrderDTO.setMemo`，奥创就会知道将`ViewModel`里面的`memo`的表单值通过java反射方式调用set方法`set`到订单的`memo`里面

## 四、独立签约

![](https://gw.alipayobjects.com/zos/skylark/2c25541f-2123-48b4-9e2b-dd2464d6152d/2018/png/e00934e2-ae00-44c1-a014-81a8622ee47f.png)



## 五、独立解约

![](https://gw.alipayobjects.com/zos/skylark/80001313-b001-4116-9d77-c3cffcba4c80/2018/png/b8ce921d-0a1b-4c7f-9540-2bcef43c1202.png)



## 六、优化

### 6.1. 数据一致性问题

#### 6.1.1. 免密支付有如下几个数据一致性问题

* 用户支付并签约或与支付宝签约成功后，LiteTao后台未收到通知，一直呈现未签约状态怎么办？

  > 当用户支付并签约或独立签约动作产生后，LiteTao后台到支付宝查询签约状态，若未查到，则按延时轮询查询轮询5次后发现还未查到则放弃，通过补偿实现最终一致性

* 用户解约后，由于系统异常未收到返回结果或未收到异步解约结果，用户一直看到的是已签约状态怎么办？

  > 当用户解约动作发生或，若解约失败，再发起一次签约协议查询，以最新的签约协议为准同步数据保障一致

* 用户与支付宝签约成功后，用户再次发起免密支付签约，支付宝如何反馈消息？

  * 提示重复签约？

  * 让用户再签一次？再签一次的话，先前成功的数据若再通知到商户后台引起数据错乱怎么解？

  * 怎么反馈让用户看的明白异常信息？

  > 鉴于以上情况，解决办法同问题一，若发现用户有签约动作，通过轮询查询支付宝签约结果补偿数据

接入RocketMQ，在用户触发签约动作后发出消息，Listener若发现数据未同步尝试重试，直到数据同步，次数限制10次



#### 6.1.2. 数据双写

* 依赖支付宝回调通知将签约协议写入LiteTao后台

* 同时定时轮询回补免密支付签约协议，若一阶段时间内都无法查询到，说明签约失败，放弃本次签约

* 提供人工触发为用户查询并回补签约信息的入口

  ​

### 6.2. 监控

#### 6.2.1. 签约解约日志

对每次签约解约的动作、请求参数、处理结果进行记录，接入TLog，或持久化到Mysql，以便查备

#### buy2业务日志



### 6.3. 安全

* 不依赖客户端数据，以异步通知或直接导支付宝查询的数据为准

* 签名，验证签等机制保障数据安全

## 七、交易流程

> 在交易流程要涉及的拓展点

### 7.1. 下单预览域业务方加入View

```


@AbilityExtension
(
name
=
"【购物单】业务方自定义渲染用的View"
, 
code
=
EXT_POINT_BUILD_CUSTOMIZED_VIEW
)


List
<
ViewModel
>
registerCustomizedViews
(
ShoppingTarget
shoppingTarget
);


// 在自己的扩展点中加入业务名称是"withholding"的ViewModel
```

### 7.2. 支付域拦截加入免密支付参数

```


@AbilityExtension
(
name
=
"小额免密支付参数构建"
, 
code
=
EXT_POINT_USE_SMALL_AMOUNT_WITHHOLDING
)


WithholdingOptions
useSmallAmountWithholding
(
BuildCheckoutInfoReq
req
);


// 在自己的扩展点中加入条件判断、免密支付上下文参数透传逻辑
```



### 存储方案



## 奥创References

* 较直观的奥创解释:[https://www.atatech.org/articles/69188](https://www.atatech.org/articles/69188)

* 一篇很详细的操作手册:[https://www.atatech.org/articles/71691](https://www.atatech.org/articles/71691)

* 然后可以看看奥创宏观架构:[https://www.atatech.org/articles/64140](https://www.atatech.org/articles/64140)

* 奥创基础使用手册:[http://gitlab.alibaba-inc.com/ultron/ultron-doc/issues](http://gitlab.alibaba-inc.com/ultron/ultron-doc/issues)



